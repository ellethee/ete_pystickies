#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    Silly listener/sender for Zhorn Software Stickies
    (http://www.zhornsoftware.co.uk/stickies/)


    license: GNU General Public License (GPL) 2.0
    (http://www.gnu.org/licenses/gpl-2.0.html)
"""
__file_name__ = "ete_pystickies.py"
__author__ =    "Luca Zaccaria <luca.vs800@hotmail.it>"
__version__ =   "1.1.3"
__date__ =      "2012-06-13"


import os
import sys
from os.path import join
import socket
import binascii
import re
import struct
from tempfile import NamedTemporaryFile
import threading
import signal
from subprocess import call
import daemon
import subprocess
import shlex
import yaml

from optparse import OptionParser


STD_PORT = 52673
rec = re.compile(r'^(\w+)=(.*)',  re.MULTILINE)

def get_name(address, filename):
    """
    Retrieve info by address.
    """
    rawstr = r'^(?P<id1>\d)\|(?P<id2>0)\|(?P<name>.*)=(?P<ip>%s)\|(?P<port>\d*)\|$' % address
    match_obj = re.search(rawstr, open(filename, "rb").read(),  re.MULTILINE)
    if match_obj:
        try:
            print match_obj.groups()
            return [match_obj.group('name'), 
                    match_obj.group('ip'), match_obj.group('port')]
        except Exception as e:
            print e
            return None
    else:
        try:
            return [socket.gethostbyaddr(address), address, None]
        except Exception as e:
            print e
            return None

def get_ip(nome, filename):
    """
    Retrieve info by name
    """
    rawstr = r'^(?P<id1>\d)\|(?P<id2>0)\|(?P<name>%s)=(?P<ip>.*)\|(?P<port>\d*)\|$' % nome
    match_obj = re.search(rawstr, open(filename, "rb").read(),  re.MULTILINE)
    if match_obj:
        try:
            print match_obj.groups()
            return [socket.gethostbyname(match_obj.group('ip')), 
                    match_obj.group('name'), match_obj.group('port')]
        except Exception as e:
            print e
            return None
    else:
        try:
            return [socket.gethostbyname(nome), nome, None]
        except Exception as e:
            print e
            return None

#: custom exception to handle SIGTERM when needed
class StickyCloseError(Exception):pass

def check_output(command):
    """
        A silly version of check_output that works with python 2.6
    """
    if isinstance(command, basestring):
        command = shlex.split(command)
    p = subprocess.Popen(command, stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE)
    out, err = p.communicate()
    return out

class EteDumbObj(dict):
    """ Dumb class to use a dictionary as an object.  """
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)

    def __getattr__(self, name):
        if name in self.__dict__:
            return self.__dict__[name]
        else:
            return self.get(name, None)

    def __setattr__(self, name, value):
        if name in self.__dict__:
            self.__dict__[name] = value
        else:
            self[name] = value

    def __delattr__(self, name):
        del self[name]

    def __dir__(self):
        return self.keys() + self.__dict__.keys()

    def __getstate__(self):
        return dict(self.items())

class Config(EteDumbObj):
    """
        Silly configuration from yaml
    """
    def __init__(self, *args, **kwargs):
        self.__dict__['_filename'] = None
        if len(args) == 1 and isinstance(args[0], basestring):
            filename = args[0]
            if not os.path.exists(filename):
                in_file = open(filename, "wb")
                in_file.close()
            self._filename = filename
            with open(self._filename, "rb") as f:
                EteDumbObj.__init__(self, yaml.load(f.read()))
        else:
            EteDumbObj.__init__(self, *args, **kwargs)

    def __getattr__(self, name):
        if name in self.__dict__:
            return self.__dict__[name]
        else:
            return self.get(name, self.get(name.upper(), None))

    def __setattr__(self, name, value):
        if name in ['save', 'optset']:
            raise KeyError("%s cannot be used as a key")
        elif name in self.__dict__:
            self.__dict__[name] = value
        elif name.upper() in self.keys():
            self[name.upper()] = value
        else:
            self[name] = value

    def save(self, filename=None):
        """
        Save the config
        """
        filename = filename or self._filename
        with open(filename, 'wb') as f:
            f.write(yaml.dump(dict(self.items()), default_flow_style=False))

    def optset(self, options, force=False):
        """
        Set config according to the options dictionary.
        If *force* is True overwrites the value, else takes the most
        significant.
        """
        for key, value in options.items():
            if  not force:
                value = value or getattr(self, key, None)
            setattr(self, key, value)

class Sticky(object):
    """
       The Stickie handler. 
    """
    def __init__(self, parent, connection, address, cfg):
        self.parent = parent
        self.conn = connection
        self.addr = address
        self.cfg = cfg
        self.data = ''
        self.closed = False
        self.sticky = EteDumbObj()
        self.sequenza = ['W', 'COL', 'TEXT', 'RTF', 'TO', 'PORT', 'HEIGHT']
        if self.conn != None:
            self.receive()


    def receive(self):
        """
        Starts to receiving data...
        """
        while True:
            data = self.conn.recv(1024)
            if not data: break
            self.data += data
            if self.cfg.debug: self.cfg.logfile.write(data)
        """
        Gets some information.
        """
        self.length, self.command, self.data = \
                re.split(r'#(\w+)\s', self.data, maxsplit=1)
        """
        Retreive more informations.
        """
        self.data_from_command()
        self.sticky.PORT = self.sticky.PORT or STD_PORT
        name = get_name(self.addr[0], self.cfg.friendsfile)
        if name == None:
            name = self.addr[0]
        else:
            name = name[0]
        """
        Let's try to advise the user via notify-send.
        """
        try:
            call(["notify-send","-u", "normal", 
                "EtePyStickies: message from %s\n" % name, 
                self.sticky.TEXT.replace('\r', '')[:50]])
        except:
            pass
        """
        And call the action if there is one.
        """
        if self.action:
            self.action()

    def data_from_command(self):
        """
        Process data depending on the command.
        """
        self.action = None
        if self.command == 'sticky':
            """
            It's a Sticky, let's take all the properties and then open
            the Sticky.
            """
            lst = rec.findall(self.data)
            self.sequenza = [l[0] for l in lst]
            self.sticky = EteDumbObj(lst)
            self.action = self.open
        elif self.command == 'send':
            """
            TODO: i have to implement this.
            """
            pass
        elif self.command == '3friends':
            """
            Seems someone is sending a Friends list. let's save it.
            """
            with open(self.cfg.friendsfile, 'wb') as f:
                f.write(self.data)

    def send(self, filename):
        """
        Sends the Sticky.
        """
        with open(filename) as f:
            """
            let's make some conversion... but i'm still confused.
            """
            s = f.read()
            if self.cfg.signit:
                """
                Signature if is needed.
                """
                s += "\n%s." % self.cfg.myname
            if self.cfg.rtf:
                self.sticky.RTF = f.read().replace('\n', '\r')
            else:
                self.sticky.RTF = r'{\rtf1'
                self.sticky.RTF += s.replace("\n", "\\par\r") +  "}"
                self.sticky.TEXT = s.replace('\n', '\r')
        data = ''
        """
        ok we will take the port where to send.
        """
        port = int(self.sticky.PORT)
        """
        And set the port where to send back.
        """
        self.sticky.PORT = self.cfg.port
        """
        Ok fill the data string with rights thing according with the original 
        sequence.
        """
        for key in self.sequenza:
            data += "%s=%s\n" % (key, self.sticky[key])
        data = '#sticky ' + data
        """
        Add data length to the beginning.
        """
        data = "\xff" + struct.pack('H', len(data)) + data
        if self.cfg.debug: self.cfg.logfile.write(data)
        """
        Ok and now is time to send.
        """
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((self.addr[0], port))
            s.send(data)
            s.close()
        except Exception as (errn, mess):
            print "I can't send the message: %s" % mess

    def ask_for_friends(self):
        """
        Ask to the defined server for a friends list.
        """
        data = "#send 3friends:%s" % self.cfg.port
        data = "\xff" + struct.pack('H', len(data)) + data
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            serverip = get_ip(self.cfg.serverip)
            s.connect((serverip, self.cfg.serverport))
            s.send(data)
            s.close()
        except:
            print "Cannot connect to the serever."
        
    def new(self):
        """
        Prepare for the new message.
        """
        self.sticky.W = self.cfg.witdh or 250
        self.sticky.RTF = ''
        self.sticky.TEXT = ''
        self.sticky.TO = self.addr[1]
        self.sticky.HEIGHT = self.cfg.height or 200
        self.sticky.COL = self.cfg.col or "255,255,180"
        self.sticky.PORT = self.addr[2] or self.cfg.port
        self.open()
        
    def open(self):
        """
        Open the temporary file and send it if there are some changes.
        """
        f = NamedTemporaryFile(delete=False)
        fname = f.name
        if self.cfg.rtf:
            fcontent = self.sticky.RTF
        else:
            fcontent = self.sticky.TEXT
        """
        I'm not so sure if is this the right replacment.
        """
        fcontent = fcontent.replace(r'^M', '\n')
        f.write(fcontent)
        f.close()
        kcheck = binascii.crc32(open(fname).read())
        check_output("%s %s" % (self.cfg.cmd, fname))
        if binascii.crc32(open(fname, 'rb').read()) != kcheck:
            self.send(fname)
        os.unlink(fname)
        if self.conn:
            self.conn.close()
        self.closed = True


class StickiesListener(object):
    """
        Listener
    """
    def __init__(self, cfg):
        self.cfg = cfg
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind((self.cfg.host, self.cfg.port))
        self.socket.listen(1)
        signal.signal(signal.SIGTERM, self.close)
        self.listen()

    def close(self, sig, frame=None):
        """
        Avoid the closing of the listener if there are some ope threads.
        """
        count = threading.active_count()
        if count > 1:
            call(["notify-send","-u", "critical", "Ete PyStickies",
                "Non posso uscire ci sono ancora %s messaggi aperti." % \
                        (count - 1)])
            raise StickyCloseError

    def listen(self):
        """
        Starts to listen.
        """
        lista = []
        while True:
            try:
                conn, addr = self.socket.accept()
                print "Connessione da %s" % str(addr)
                self.cfg.logfile.flush()
                t = threading.Thread(target=Sticky, 
                        args=(self, conn, addr, self.cfg))
                lista.append(t)
                t.start()
            except KeyboardInterrupt:
                print "Closing by CTRL+C..."
                break
            except StickyCloseError:
                pass
            except socket.error as (errno, msg):
                if errno == 4:
                    print "Closing by SIGTERM..."
                    break
                else:
                    raise
        for s in lista:
            try:
                s.conn.close()
            except:
                pass
            del s
        del lista


        
if __name__ == "__main__":
    p = OptionParser(version="%prog " + __version__, 
            usage="usage: %prog [options] [friend|pcname|address]")
    ehome = join(os.path.expanduser('~'), '.ete_pystickies')
    p.description = "Silly program to receive and send Zhorn Software Stickies."\
    "\n%prog supports completion for friend's names, where avaible "\
    "(remember to use double quotes)."
    p.add_option('-l', '--listen', dest='listen', action='store_true', 
            default=False, help="Starts in listening mode to accept incoming "
            "Stickies.")
    p.add_option('-d', '--daemon', dest='daemon', action='store_true', 
            default=False, help="Used with -listen starts %prog as daemon.")
    p.add_option('-f', '--friends', dest='friends', action='store_true',
            default=False, help="Ask for friends.")
    p.add_option('-g', '--debug', dest='debug', action="store_true",
            default=False, help="Writes some info to the log")
    options, args = p.parse_args() 
    cfg = Config(join(ehome, 'ete_pystickiesrc'))
    cfg.logfile = open(join(ehome, 'ete_pystickies.log'), "w+")
    cfg.friendsfile = join(ehome, "friends")
    cfg.home = ehome
    cfg.cwd = os.getcwd()
    cfg.optset(vars(options))
    if options.listen:
        os.sys.path.append(cfg.cwd)
        if not 'In' in locals() and options.daemon:
            dm = daemon.DaemonContext(working_directory=str(cfg.cwd),
                    stdout=cfg.logfile, stderr=cfg.logfile)
            dm.open()
        StickiesListener(cfg)
        print "Closed."
    elif options.friends:
        s = Sticky(None, None, None, cfg)
        s.ask_for_friends()
        del s
    else:
        if len(args):
            ip = get_ip(args[0], cfg.friendsfile)
            if ip:
                s = Sticky(None, None, ip, cfg)
                s.new()
            else:
                print "pare non ci sia nessuno collegato per", args[0]
    cfg.logfile.close()
    sys.exit(0)
